INTERVAL GRAPHS
----------------------------------------------------------------------
# RECOGNITION

from graphtheory.structures.edges import Edge
from graphtheory.structures.graphs import Graph

----------------------------------------------------------------------
# GENERATORS

----------------------------------------------------------------------
# TRAVERSING (BFS)

from graphtheory.chordality.intervalbfs import IntervalBFS

# 0---4---3   2tree graph
# | \ | /
# 2---1
#
# 2-----2
#   0-------0
#     1-------------1
#         4-----4
#             3---3

perm = [2,0,1,2,4,0,3,4,3,1]
preorder = []
postorder = []
algorithm = IntervalBFS(perm)
algorithm.run(0, pre_action=lambda node: preorder.append(node),
                post_action=lambda node: postorder.append(node))
print(preorder)   # [0, 1, 2, 4, 3]
print(postorder)   # [0, 1, 2, 4, 3]
print(algorithm.parent)   # {0: None, 1: 0, 2: 0, 3: 1, 4: 0}
print(algorithm.path(0, 3))    # [0, 1, 3]
print(algorithm.path(0, 1))   # [0, 1]
----------------------------------------------------------------------
# TRAVERSING (DFS)

from graphtheory.chordality.intervaldfs import IntervalDFS

# 0---4---3   2tree graph
# | \ | /
# 2---1
#
# 2-----2
#   0-------0
#     1-------------1
#         4-----4
#             3---3

perm = [2,0,1,2,4,0,3,4,3,1]   # interval graph as double perm
preorder = []
postorder = []
algorithm = IntervalDFS(perm)
algorithm.run(0, pre_action=lambda node: preorder.append(node),
                post_action=lambda node: postorder.append(node))
print(preorder)   # [0, 1, 2, 3, 4]
print(postorder)   # [2, 4, 3, 1, 0]
print(algorithm.parent)   # {0: None, 1: 0, 2: 1, 3: 1, 4: 3}
print(algorithm.path(0, 1))   # [0, 1]
print(algorithm.path(0, 3))   # [0, 1, 3]
----------------------------------------------------------------------
EOF
