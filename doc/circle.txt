CIRCLE GRAPHS
----------------------------------------------------------------------
# RECOGNITION

from graphtheory.structures.edges import Edge
from graphtheory.structures.graphs import Graph

----------------------------------------------------------------------
# GENERATORS
from graphtheory.permutations.circletools import make_random_circle
from graphtheory.permutations.circletools import make_path_circle
from graphtheory.permutations.circletools import make_cycle_circle
from graphtheory.permutations.circletools import make_tepee_circle

# perm has (double) numbers from 0 to n-1.
n = 10
perm = make_random_circle(n)
perm = make_path_circle(n)   # make perm for path graph P_n
perm = make_cycle_circle(n)   # make perm for cycle graph C_n
perm = make_tepee_circle(n)   # make perm for tepee graph

assert len(perm) == 2*n
assert sorted(perm) == sorted(2 * list(range(n)))
----------------------------------------------------------------------
FUNCTIONS
from graphtheory.permutations.circletools import is_perm_graph
from graphtheory.permutations.circletools import circle_has_edge
from graphtheory.permutations.circletools import circle_is_connected

assert is_perm_graph([0, 1, 0, 1])   # P_2 graph
assert not is_perm_graph([4, 1, 0, 2, 1, 3, 2, 4, 3, 0])   # C_5 graph

perm = [3, 1, 0, 2, 1, 3, 2, 0]   # C_4 graph
assert circle_is_connected(perm)
assert is_perm_graph(perm)   # O(n) time, O(n) memory
assert circle_has_edge(perm, 0, 1)   # O(n) time, O(n) memory
assert not circle_has_edge(perm, 0, 2)
----------------------------------------------------------------------
TRAVERSING
from graphtheory.permutations.circlebfs import CircleBFS
from graphtheory.permutations.circledfs import CircleDFS

# Using BFS/DFS in O(n^2) time.
perm = [...]   # circle graph as a double perm (list)
source = ...   # starting node
pre_order = []
post_order = []
algorithm = CircleBFS(perm)
#algorithm = CircleDFS(perm)
algorithm.run(source,
    pre_action=lambda node: pre_order.append(node),
    post_action=lambda node: post_order.append(node))
# Results.
print(pre_order)   # node list
print(post_order)   # node list
print(algorithm.parent)   # BFS/DFS tree as a dict
print(algorithm.path(source, target)   # node list
----------------------------------------------------------------------
EOF
